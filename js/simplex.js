/*
* Author: Stefan Gustavson ITN-LiTH (stegu@itn.liu.se) 2004-12-05
* Simplex indexing functions by Bill Licea-Kane, ATI
*
* You may use, modify and redistribute this code free of charge,
* provided that the author's names and this notice appear intact.
*/

/*
 * Stringified and condensed here to reduce cluter in main color particles app
 */
var simplexVertexShader = "\n\n\t\t precision highp float;\n\n\t\t /*\n\t\t  * 2D, 3D and 4D Perlin noise, classic and simplex, in a GLSL fragment shader.\n\t\t  *\n\t\t  * Classic noise is implemented by the functions:\n\t\t  * float noise(vec2 P)\n\t\t  * float noise(vec3 P)\n\t\t  * float noise(vec4 P)\n\t\t  *\n\t\t  * Simplex noise is implemented by the functions:\n\t\t  * float snoise(vec2 P)\n\t\t  * float snoise(vec3 P)\n\t\t  * float snoise(vec4 P)\n\t\t  *\n\t\t  * Author: Stefan Gustavson ITN-LiTH (stegu@itn.liu.se) 2004-12-05\n\t\t  * Simplex indexing functions by Bill Licea-Kane, ATI\n\t\t  *\n\t\t  * You may use, modify and redistribute this code free of charge,\n\t\t  * provided that the author's names and this notice appear intact.\n\t\t  */\n\n\t\t /*\n\t\t  * The value of classic 4D noise goes above 1.0 and below -1.0 at some\n\t\t  * points. Not much and only very sparsely, but it happens. This is a\n\t\t  * bug from the original software implementation, so I left it untouched.\n\t\t  */\n\n\n\t\t /*\n\t\t  * \"permTexture\" is a 256x256 texture that is used for both the permutations\n\t\t  * and the 2D and 3D gradient lookup. For details, see the main C program.\n\t\t  * \"gradTexture\" is a 256x256 texture with 4D gradients, similar to\n\t\t  * \"permTexture\" but with the permutation index in the alpha component\n\t\t  * replaced by the w component of the 4D gradient.\n\t\t  * 2D classic noise uses only permTexture.\n\t\t  * 2D simplex noise uses only permTexture.\n\t\t  * 3D classic noise uses only permTexture.\n\t\t  * 3D simplex noise uses only permTexture.\n\t\t  * 4D classic noise uses permTexture and gradTexture.\n\t\t  * 4D simplex noise uses permTexture and gradTexture.\n\t\t  */\n\t\t uniform sampler2D permTexture;\n\t\t uniform sampler2D gradTexture;\n\t\t uniform float time; // Used for texture animation\n\n\t\t /*\n\t\t  * Both 2D and 3D texture coordinates are defined, for testing purposes.\n\t\t  */\n\t\t varying vec3 vTextureCoord;\n\n\t\t /*\n\t\t  * To create offsets of one texel and one half texel in the\n\t\t  * texture lookup, we need to know the texture image size.\n\t\t  */\n\t\t #define ONE 0.00390625\n\t\t #define ONEHALF 0.001953125\n\t\t // The numbers above are 1/256 and 0.5/256, change accordingly\n\t\t // if you change the code to use another perm/grad texture size.\n\n\n\t\t /*\n\t\t  * The 5th degree smooth interpolation function for Perlin \"improved noise\".\n\t\t  */\n\t\t float fade(const in float t) {\n\t\t  return t*t*t*(t*(t*6.0-15.0)+10.0); // Improved fade, yields C2-continuous noise\n\t\t }\n\n\t\t /*\n\t\t  * Efficient simplex indexing functions by Bill Licea-Kane, ATI. Thanks!\n\t\t  * (This was originally implemented as a texture lookup. Nice to avoid that.)\n\t\t  */\n\t\t void simplex( const in vec3 P, out vec3 offset1, out vec3 offset2 )\n\t\t {\n\t\t  vec3 offset0;\n\n\t\t  vec2 isX = step( P.yz, P.xx );     // P.x >= P.y ? 1.0 : 0.0; P.x >= P.z ? 1.0 : 0.0;\n\t\t  offset0.x = dot( isX, vec2( 1.0 ) ); // Accumulate all P.x >= other channels in offset.x\n\t\t  offset0.yz = 1.0 - isX;        // Accumulate all P.x < other channels in offset.yz\n\n\t\t  float isY = step( P.z, P.y );     // P.y >= P.z ? 1.0 : 0.0;\n\t\t  offset0.y += isY;           // Accumulate P.y >= P.z in offset.y\n\t\t  offset0.z += 1.0 - isY;        // Accumulate P.y < P.z in offset.z\n\n\t\t  // offset0 now contains the unique values 0,1,2 in each channel\n\t\t  // 2 for the channel greater than other channels\n\t\t  // 1 for the channel that is less than one but greater than another\n\t\t  // 0 for the channel less than other channels\n\t\t  // Equality ties are broken in favor of first x, then y\n\t\t  // (z always loses ties)\n\n\t\t  offset2 = clamp(  offset0, 0.0, 1.0 );\n\t\t  // offset2 contains 1 in each channel that was 1 or 2\n\t\t  offset1 = clamp( --offset0, 0.0, 1.0 );\n\t\t  // offset1 contains 1 in the single channel that was 1\n\t\t }\n\n\t\t void simplex( const in vec4 P, out vec4 offset1, out vec4 offset2, out vec4 offset3 )\n\t\t {\n\t\t  vec4 offset0;\n\n\t\t  vec3 isX = step( P.yzw, P.xxx );    // See comments in 3D simplex function\n\t\t  offset0.x = dot( isX, vec3( 1.0 ) );\n\t\t  offset0.yzw = 1.0 - isX;\n\n\t\t  vec2 isY = step( P.zw, P.yy );\n\t\t  offset0.y += dot( isY, vec2( 1.0 ) );\n\t\t  offset0.zw += 1.0 - isY;\n\n\t\t  float isZ = step( P.w, P.z );\n\t\t  offset0.z += isZ;\n\t\t  offset0.w += 1.0 - isZ;\n\n\t\t  // offset0 now contains the unique values 0,1,2,3 in each channel\n\n\t\t  offset3 = clamp(  offset0, 0.0, 1.0 );\n\t\t  offset2 = clamp( --offset0, 0.0, 1.0 );\n\t\t  offset1 = clamp( --offset0, 0.0, 1.0 );\n\t\t }\n\n\n\t\t /*\n\t\t  * 3D simplex noise. Comparable in speed to classic noise, better looking.\n\t\t  */\n\t\t float snoise(const in vec3 P) {\n\n\t\t // The skewing and unskewing factors are much simpler for the 3D case\n\t\t #define F3 0.333333333333\n\t\t #define G3 0.166666666667\n\n\t\t  // Skew the (x,y,z) space to determine which cell of 6 simplices we're in\n\t\t   float s = (P.x + P.y + P.z) * F3; // Factor for 3D skewing\n\t\t  vec3 Pi = floor(P + s);\n\t\t  float t = (Pi.x + Pi.y + Pi.z) * G3;\n\t\t  vec3 P0 = Pi - t; // Unskew the cell origin back to (x,y,z) space\n\t\t  Pi = Pi * ONE + ONEHALF; // Integer part, scaled and offset for texture lookup\n\n\t\t  vec3 Pf0 = P - P0; // The x,y distances from the cell origin\n\n\t\t  // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n\t\t  // To find out which of the six possible tetrahedra we're in, we need to\n\t\t  // determine the magnitude ordering of x, y and z components of Pf0.\n\t\t  vec3 o1;\n\t\t  vec3 o2;\n\t\t  simplex(Pf0, o1, o2);\n\n\t\t  // Noise contribution from simplex origin\n\t\t  float perm0 = texture2D(permTexture, Pi.xy).a;\n\t\t  vec3 grad0 = texture2D(permTexture, vec2(perm0, Pi.z)).rgb * 4.0 - 1.0;\n\t\t  float t0 = 0.6 - dot(Pf0, Pf0);\n\t\t  float n0;\n\t\t  if (t0 < 0.0) n0 = 0.0;\n\t\t  else {\n\t\t   t0 *= t0;\n\t\t   n0 = t0 * t0 * dot(grad0, Pf0);\n\t\t  }\n\n\t\t  // Noise contribution from second corner\n\t\t  vec3 Pf1 = Pf0 - o1 + G3;\n\t\t  float perm1 = texture2D(permTexture, Pi.xy + o1.xy*ONE).a;\n\t\t  vec3 grad1 = texture2D(permTexture, vec2(perm1, Pi.z + o1.z*ONE)).rgb * 4.0 - 1.0;\n\t\t  float t1 = 0.6 - dot(Pf1, Pf1);\n\t\t  float n1;\n\t\t  if (t1 < 0.0) n1 = 0.0;\n\t\t  else {\n\t\t   t1 *= t1;\n\t\t   n1 = t1 * t1 * dot(grad1, Pf1);\n\t\t  }\n\n\t\t  // Noise contribution from third corner\n\t\t  vec3 Pf2 = Pf0 - o2 + 2.0 * G3;\n\t\t  float perm2 = texture2D(permTexture, Pi.xy + o2.xy*ONE).a;\n\t\t  vec3 grad2 = texture2D(permTexture, vec2(perm2, Pi.z + o2.z*ONE)).rgb * 4.0 - 1.0;\n\t\t  float t2 = 0.6 - dot(Pf2, Pf2);\n\t\t  float n2;\n\t\t  if (t2 < 0.0) n2 = 0.0;\n\t\t  else {\n\t\t   t2 *= t2;\n\t\t   n2 = t2 * t2 * dot(grad2, Pf2);\n\t\t  }\n\n\t\t  // Noise contribution from last corner\n\t\t  vec3 Pf3 = Pf0 - vec3(1.0-3.0*G3);\n\t\t  float perm3 = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a;\n\t\t  vec3 grad3 = texture2D(permTexture, vec2(perm3, Pi.z + ONE)).rgb * 4.0 - 1.0;\n\t\t  float t3 = 0.6 - dot(Pf3, Pf3);\n\t\t  float n3;\n\t\t  if(t3 < 0.0) n3 = 0.0;\n\t\t  else {\n\t\t   t3 *= t3;\n\t\t   n3 = t3 * t3 * dot(grad3, Pf3);\n\t\t  }\n\n\t\t  // Sum up and scale the result to cover the range [-1,1]\n\t\t  return 32.0 * (n0 + n1 + n2 + n3);\n\t\t }\n\n\n\t\t /*\n\t\t  * 4D simplex noise. A lot faster than classic 4D noise, and better looking.\n\t\t  */\n\n\t\t float snoise(const in vec4 P) {\n\n\t\t // The skewing and unskewing factors are hairy again for the 4D case\n\t\t // This is (sqrt(5.0)-1.0)/4.0\n\t\t #define F4 0.309016994375\n\t\t // This is (5.0-sqrt(5.0))/20.0\n\t\t #define G4 0.138196601125\n\n\t\t  // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n\t\t   float s = (P.x + P.y + P.z + P.w) * F4; // Factor for 4D skewing\n\t\t  vec4 Pi = floor(P + s);\n\t\t  float t = (Pi.x + Pi.y + Pi.z + Pi.w) * G4;\n\t\t  vec4 P0 = Pi - t; // Unskew the cell origin back to (x,y,z,w) space\n\t\t  Pi = Pi * ONE + ONEHALF; // Integer part, scaled and offset for texture lookup\n\n\t\t  vec4 Pf0 = P - P0; // The x,y distances from the cell origin\n\n\t\t  // For the 4D case, the simplex is a 4D shape I won't even try to describe.\n\t\t  // To find out which of the 24 possible simplices we're in, we need to\n\t\t  // determine the magnitude ordering of x, y, z and w components of Pf0.\n\t\t  vec4 o1;\n\t\t  vec4 o2;\n\t\t  vec4 o3;\n\t\t  simplex(Pf0, o1, o2, o3);\n\n\t\t  // Noise contribution from simplex origin\n\t\t  float perm0xy = texture2D(permTexture, Pi.xy).a;\n\t\t  float perm0zw = texture2D(permTexture, Pi.zw).a;\n\t\t  vec4 grad0 = texture2D(gradTexture, vec2(perm0xy, perm0zw)).rgba * 4.0 - 1.0;\n\t\t  float t0 = 0.6 - dot(Pf0, Pf0);\n\t\t  float n0;\n\t\t  if (t0 < 0.0) n0 = 0.0;\n\t\t  else {\n\t\t   t0 *= t0;\n\t\t   n0 = t0 * t0 * dot(grad0, Pf0);\n\t\t  }\n\n\t\t  // Noise contribution from second corner\n\t\t  vec4 Pf1 = Pf0 - o1 + G4;\n\t\t  o1 = o1 * ONE;\n\t\t  float perm1xy = texture2D(permTexture, Pi.xy + o1.xy).a;\n\t\t  float perm1zw = texture2D(permTexture, Pi.zw + o1.zw).a;\n\t\t  vec4 grad1 = texture2D(gradTexture, vec2(perm1xy, perm1zw)).rgba * 4.0 - 1.0;\n\t\t  float t1 = 0.6 - dot(Pf1, Pf1);\n\t\t  float n1;\n\t\t  if (t1 < 0.0) n1 = 0.0;\n\t\t  else {\n\t\t   t1 *= t1;\n\t\t   n1 = t1 * t1 * dot(grad1, Pf1);\n\t\t  }\n\n\t\t  // Noise contribution from third corner\n\t\t  vec4 Pf2 = Pf0 - o2 + 2.0 * G4;\n\t\t  o2 = o2 * ONE;\n\t\t  float perm2xy = texture2D(permTexture, Pi.xy + o2.xy).a;\n\t\t  float perm2zw = texture2D(permTexture, Pi.zw + o2.zw).a;\n\t\t  vec4 grad2 = texture2D(gradTexture, vec2(perm2xy, perm2zw)).rgba * 4.0 - 1.0;\n\t\t  float t2 = 0.6 - dot(Pf2, Pf2);\n\t\t  float n2;\n\t\t  if (t2 < 0.0) n2 = 0.0;\n\t\t  else {\n\t\t   t2 *= t2;\n\t\t   n2 = t2 * t2 * dot(grad2, Pf2);\n\t\t  }\n\n\t\t  // Noise contribution from fourth corner\n\t\t  vec4 Pf3 = Pf0 - o3 + 3.0 * G4;\n\t\t  o3 = o3 * ONE;\n\t\t  float perm3xy = texture2D(permTexture, Pi.xy + o3.xy).a;\n\t\t  float perm3zw = texture2D(permTexture, Pi.zw + o3.zw).a;\n\t\t  vec4 grad3 = texture2D(gradTexture, vec2(perm3xy, perm3zw)).rgba * 4.0 - 1.0;\n\t\t  float t3 = 0.6 - dot(Pf3, Pf3);\n\t\t  float n3;\n\t\t  if (t3 < 0.0) n3 = 0.0;\n\t\t  else {\n\t\t   t3 *= t3;\n\t\t   n3 = t3 * t3 * dot(grad3, Pf3);\n\t\t  }\n\n\t\t  // Noise contribution from last corner\n\t\t  vec4 Pf4 = Pf0 - vec4(1.0-4.0*G4);\n\t\t  float perm4xy = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a;\n\t\t  float perm4zw = texture2D(permTexture, Pi.zw + vec2(ONE, ONE)).a;\n\t\t  vec4 grad4 = texture2D(gradTexture, vec2(perm4xy, perm4zw)).rgba * 4.0 - 1.0;\n\t\t  float t4 = 0.6 - dot(Pf4, Pf4);\n\t\t  float n4;\n\t\t  if(t4 < 0.0) n4 = 0.0;\n\t\t  else {\n\t\t   t4 *= t4;\n\t\t   n4 = t4 * t4 * dot(grad4, Pf4);\n\t\t  }\n\n\t\t  // Sum up and scale the result to cover the range [-1,1]\n\t\t  return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\t\t }\n\n\n\t\t";